<!doctype html>
<html>
<head>
	<title>Circle</title>
	<script type='text/javascript' src="d3/d3.js"></script>
	<script type='text/javascript' src="d3/d3.min.js"></script>
</head>
<body>
	<script>

		var canvas_height = 1000;
		var canvas_width = 1000;
		var canvas = d3.select("body").append("svg")
			.attr('width', canvas_width)
			.attr('height', canvas_height)
			
		var group = canvas.append("g").attr("transform", "translate(100, 100)");

		loadXML("pmd_model.xml");
		//loadXML("hadoop_yarn.xml");
		//loadXML("all-of-pmd.xml");

		//Specify the D3.xml file and the callback.

		//Functions
		function loadXML(path)
		{
			//Specify the xml file and the callbackwith D3.
			d3.xml(path, xmlCallback);
		}

		function xmlCallback(error, data)
		{
			if(error) 
			{
				throw error
			}
			else
			{
				data = [].map.call(data.querySelectorAll("type"), function(type) {
					return {
						FullName: type.getAttribute("name"),
						Name: type.getAttribute("name").split(".")[type.getAttribute("name").split(".").length - 1],
						Type: type.getAttribute('classification'),
						Visibility: type.getAttribute('visibility'),
						Dependencies: [].map.call(type.querySelectorAll('depends-on'), function(dependency) {
							return {
								FullName: dependency.getAttribute("name"),
								Type: dependency.getAttribute('classification')
							};
						})
					};
				});

				var circles = group.selectAll("circle")
					.data(data)
					.enter()
						.append("circle")
						.attr("stroke", "black")
						.attr("stroke-width", 0.5)
						.attr("fill", function(d){
							if(d.Type = "class"){
								return "green";
							}
							else if(d.type = "interface"){
								return "steelblue";
							}
							else{
								return "#797979"; //Grey
							}
						})
						.attr("cy", function(d, i) { return (Math.random() * 150); })
						.attr("cx", function(d, i) { return (Math.random() * 150); })
						//.attr("transform", function(d){return "translate("+d.x+",80)"})
						.attr("r", 3.5);
							//.append("text")
			        			//.attr("dx", function(d){return -20})
			        			//.text(function(d){return d.Name})
			     data = [];
				//Create the lines to connect the circles
				//var circles = group.selectAll("circle");
				//Go through each circle and verify if they need paths drawn,
				circles.each(function(d,i){
					//Get current circle object
					var currentCircle = circles._groups[0][i];

					d.Dependencies.forEach(function(dependency){

						//Get the circle that represents this dependency
						var c = circles.filter(function(item){ return item.FullName == dependency.FullName; })
						var depCircle = c._groups[0][0];

						//Verify that we got the circle if it exists.
						if(depCircle){
							//Now draw a path line between both circles. Reference: https://github.com/d3/d3-path
							//Start coordinates
							var x1 = parseInt(currentCircle.getAttribute("cx"));
							var y1 = parseInt(currentCircle.getAttribute("cy"));

							//End coordinates
							var x2 = parseInt(depCircle.getAttribute("cx"));
							var y2 = parseInt(depCircle.getAttribute("cy"));

							//midpoint
							var m1 = (x1 + x2)/2;
							var m2 = (y1 + y2)/2;

							var lineData = [ 
										{ x: x1, y: y1},
										{ x: m1, y: m2},
										{ x: x2, y: y2}
							];

							var line = d3.line()
								.x(function(d) { return d.x; })
								.y(function(d) { return d.y; });

							group.selectAll("path")
									.data(lineData)
									.enter()
										.append("path")
										.datum(lineData)
										.attr("d", line)
										.attr("stroke", function(d){
											if(dependency.Type == "uses"){
												return "black";
											}
											else if(dependency.Type == "extends"){
												return "#2DAF47"; //Dark Lime Green
											}
											else if(dependency.Type == "implements"){
												return "#0738FF"; //Royal Blue
											}
											else{
												return "red";
											}
										})
										.attr("stroke-width", 0.8);
						}
					})
				})
			}
		}

	</script>
</body>
</html>


