# This script has logic to read the XML data generated by CDA and 
# construct the JSON files used for the D3 Packing and Node-Link View provided by SAV.
import xml
import os
import sys
import xml.etree.ElementTree as ET
import math
import json
import random
import io
from time import gmtime, strftime

dir_path = os.path.dirname(os.path.realpath(__file__))

def CreateContainerJSON(pathToXMLFile):

	print("Calling CreateContainerJSON")

	tree = ET.parse(pathToXMLFile)
	root = tree.getroot()
	context = root.findall("context")[0]
	data = []

	for container in context.findall("container"):	
		packages = container.findall('namespace')
		containerSize = len(packages)
		pArrayData = []
		for package in packages:
			packageSize = len(package.findall('type'))
			packageName = package.get('name')
			pArrayData.append({"id": getRandomPackageName(), "name": packageName, "size": packageSize})
		lastElementIndex = len(container.get('name').split("/")) - 1;
		containerName = container.get('name').split("/")[lastElementIndex]; #CDA usually places the absolute path to the JAR file. Let's only grab the actual name.
		data.append({"id": getRandomContainerName(), "name": containerName, "size": containerSize, "children": pArrayData})

	context = {"name": root.findall('context')[0].get('name'), "children": data}

	with open('output.json', 'w') as outfile:
		json.dump(context, outfile)


# This function takes the XML file and formats the data into JSON/Dictionary that 
# we can use to load the Nodes and Links in D3.
def CreateNodeLinkJSON(pathToXMLFile):

	print("Calling CreateNodeLinkJSON()")

	tree = ET.parse(pathToXMLFile)
	root = tree.getroot()
	context = root.findall("context")[0]
	Packages = []
	Links = []

	print("Start Time -> " + strftime("%H:%M:%S", gmtime()))

	for container in context.findall("container"):	
		packages = container.findall('namespace')
		containerSize = len(packages)
		pArrayData = []
		for package in packages:
			classes = package.findall('type')
			packageSize = len(classes)
			packageName = package.get('name')

			listOfMatchingElements = [p for p in Packages if p["id"] == packageName]

			if len(listOfMatchingElements) > 0 :
				#print(listOfMatchingElements)
				'''This means we already have an entry with this Package name.
				This can happen when a package entry is added as part of another packages dependency definition below.
				Update accordingly.'''
				Packages[Packages.index(listOfMatchingElements[0])]["size"] = packageSize
			else:
				#This means the package name is still not defined in the Packages node collection. 
				#So add the new entry.
				Packages.append({"id": packageName, "size": packageSize})
			for c in classes:
				if len(list(c)) > 0:
					cDependencies = c.findall('dependencies')[0].findall('depends-on')
					for dependency in cDependencies:
						arr = dependency.get("name").split(".")
						if len(arr) > 2:
							#remove the class name from the FullName string.
							arr.pop()
							firstName = arr[0]
							secondName = arr[1]
							namespaceStr = ".".join(arr)

							#Verify if it is a namespace listed in this container
							#listedPackage = [p for p in packages if p.get('name') == namespaceStr]
							#if len(listedPackage) > 0:
							newLink = {"source": packageName, "target": namespaceStr}
							found = [p for p in Packages if p["id"] == namespaceStr]
							if firstName != "java" or (firstName == "com" and secondName == "google"):
								if len(found) == 0:
									Packages.append({"id": namespaceStr, "size": 1})
								if Links.count(newLink) == 0:
									Links.append(newLink)
						else:
							print("FAILED to split string")
							print("Dependency Name -> " + dependency.get("name"))
		data = {"size": containerSize, "nodes": Packages, "links": Links}
		lastElementIndex = len(container.get('name').split("/")) - 1;
		containerArr = container.get('name').split("/")[lastElementIndex].split(".");
		containerArr.pop()
		containerName = ".".join(containerArr)
		#print("Container Name: " + containerName)
		with open(dir_path + "/Output_Data/" + containerName + ".json", 'w') as outfile:
			json.dump(data, outfile)
	print("Finish Time -> " + strftime("%H:%M:%S", gmtime()))

'''def CreateChordJSON(pathToXMLFile):

	print("Calling CreateChordJSON()")

	tree = ET.parse(pathToXMLFile)
	root = tree.getroot()
	context = root.findall("context")[0]
	Packages = []

	print("Start Time -> " + strftime("%H:%M:%S", gmtime()))

	for container in context.findall("container"):	
		packages = container.findall('namespace')
		containerSize = len(packages)
		pArrayData = []
		for package in packages:
			classes = package.findall('type')
			packageSize = len(classes)
			packageName = package.get('name')
			currentPackage = {}
			listOfMatchingElements = [p for p in Packages if p["id"] == packageName]

			if len(listOfMatchingElements) > 0 :
				currentPackage = Packages[Packages.index(listOfMatchingElements[0])]\
				currentPackage["size"] = packageSize
			else:
				currentPackage = {"name": packageName, "size": packageSize, "imports": []}
			for c in classes:
				if len(list(c)) > 0:
					cDependencies = c.findall('dependencies')[0].findall('depends-on')
					for dependency in cDependencies:
						arr = dependency.get("name").split(".")
						if len(arr) > 2:
							#remove the class name from the FullName string.
							arr.pop()
							firstName = arr[0]
							secondName = arr[1]
							namespaceStr = ".".join(arr)
							newLink = {"source": packageName, "target": namespaceStr}
							found = [p for p in Packages if p["id"] == namespaceStr]
							if firstName != "java" or (firstName == "com" and secondName == "google"):
								if len(found) == 0:
									Packages.append({"name": namespaceStr, "size": 1})
								if Links.count(newLink) == 0:
									Links.append(newLink)
						else:
							print("FAILED to split string")
							print("Dependency Name -> " + dependency.get("name"))
		data = {"size": containerSize, "nodes": Packages, "links": Links}
		lastElementIndex = len(container.get('name').split("/")) - 1;
		containerArr = container.get('name').split("/")[lastElementIndex].split(".");
		containerArr.pop()
		containerName = ".".join(containerArr)
		#print("Container Name: " + containerName)
		with open(dir_path + "/Output_Data/" + containerName + ".json", 'w') as outfile:
			json.dump(data, outfile)
	print("Finish Time -> " + strftime("%H:%M:%S", gmtime()))'''

def getRandomInteger():
	return str(random.randint(1, 1000000))

def getRandomPackageName():
	return "package" + str(getRandomInteger())

def getRandomContainerName():
	return "container" + str(getRandomInteger())



